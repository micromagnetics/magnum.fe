# Copyright (C) 2011-2015 Claas Abert
#
# This file is part of magnum.fe. 
#
# magnum.fe is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# magnum.fe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with magnum.fe. If not, see <http://www.gnu.org/licenses/>.
# 
# Last modified by Claas Abert, 2015-01-16

from __future__ import absolute_import 

from dolfin import *

from . import LLGTerm
from magnumfe import WrappedMesh, Mesher, Constants, Timer
import magnumfe.open_boundary as open_boundary

__all__ = ["DemagField"]

class DemagField(LLGTerm):

  def __init__(self, method = "transform", sample_size = None, order = 1):
    """
    Solves for the magnetic demagnetization field.

    *Arguments*
      method (:class:`string`)
        Method for the solution of the open-boundary problem.
        Possible Values are "Fredkin Koehler"/"FK" and "Shell Transform"/"ST"
      sample_size (:class:`[float]`)
        Tuple described the size of the sample. Usually this is taken from create_mesh.
      order (:class:`int`)
        The order of CG function used for the potential calculation.
    """

    if method in ("ST", "Shell Transform"):
      if sample_size == None: raise "sample_size must be provided for shell-transform method"

      self.solver = open_boundary.ShellTransform(
          lambda coeffs, v, state, measure: inner(grad(v), coeffs[0]) * state.dx('magnetic', measure),
          sample_size,
          order
        )

    elif method in ("FK", "Fredkin Koehler"):
      self.solver = open_boundary.FredkinKoehler('magnetic',
          lambda coeffs, v, n: div(coeffs[0]) * v * dx - inner(coeffs[0], n) * v * ds
        )
    else:
      raise ValueError("Method '%s' not available." % method)

  def form_term_rhs(self, state, w):
    return - state.material.ms * Constant(Constants.gamma) \
           * inner(grad(self.calculate_potential(state)), w)

  def calculate_potential(self, state):
    """
    Calculate the stray-field for a given simulation state

    *Arguments*
      state (:class:`State`)
        The simulation state
    """
    with Timer("Demag Potential"):
      return self.solver.calculate(state, state.m)

  def field(self, state, x = None, lump = False):
    with Timer("Demag Field"):
      return super(DemagField, self).field(state, x, lump)

  @staticmethod
  def create_mesh(*args, **kwargs):
    """
    Creates a WrappedMesh suited for the application of the shell-
    transformation method. Either takes a filename as first argument
    to load the meshed sample or sizes and discretization of a cuboid
    sample.

    *Example*
      .. code-block:: python

        # load from file
        mesh = DemagField.create_mesh("sphere.msh", d=2, margin=0.1, n=(10, 10, 10))

        # create cuboid mesh of size 1.0 x 1.0 x 1.0
        mesh = DemagField.create_mesh((1.0, 1.0, 1.0), (10, 10, 10), d=2)

    *Arguments*
      d (:class:`int`)
        Number of shell layers.
      scale (:class:`float`)
        Scale factor used for mesh generation.
      margin (:class:`float`)
        Margin to the sample when loading sample mesh from a file.
      n (:class:`[int]`)
        Discretization of inner cuboid when loading sample mesh from a file.
    """
    # TODO allow creation of subdomains?
    mesher = Mesher()

    if isinstance(args[0], str):
      mesher.read_file(args[0])
    elif isinstance(args[0], (list, tuple)) and isinstance(args[1], (list, tuple)):
      mesher.create_cuboid(args[0], args[1])
    else:
      error("Arguments not supported.")

    d       = kwargs.pop('d', 1)
    scale   = kwargs.pop('scale', 1.0)
    domains = kwargs.pop('domains', {})

    mesher.create_shell(d, **kwargs)

    for domain_id in domains:
      mesher.create_celldomain(domains[domain_id], domain_id)

    mesh    = mesher.mesh(scale)

    return WrappedMesh.create(mesh, (1000, 1001, 1002, 1003), True), mesher.get_sample_size(scale = scale)
