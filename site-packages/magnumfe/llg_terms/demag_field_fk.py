"""This module defines a class for the micromagnetic stray-field
computation using the FEM-BEM coupling as proposed by Fredkin and Koehler."""

# Copyright (C) 2011-2012 Claas Abert
#
# This file is part of magnum.fe. 
#
# magnum.fe is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# magnum.fe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with magnum.fe. If not, see <http://www.gnu.org/licenses/>.
# 
# First added:  2012-11-30
# Last changed: 2012-11-30

from __future__ import absolute_import 

from dolfin import *
try:
  from bempp.lib import *
  _found_bempp = True
except:
  # TODO log warning
  _found_bempp = False

import numpy as np

from magnumfe.llg_terms import LLGTerm
from magnumfe.constants import Constants
from magnumfe import WrappedMesh

__all__ = ["DemagFieldFK"]

# TODO handle differnet regions
class DemagFieldFK(LLGTerm):
  """
  This class defines methods for the micromagnetic stray-field computation.
  It uses the FEM-BEM coupling as proposed by Fredkin and Koehler.
  """

  def __init__(self):
    """
    Create a _DemagFieldFK_ object.
    """
    #if not _found_bempp: TODO log warning

  def _assemble(self, state):
    """
    Helper method that assembles the mesh dependent system matrices and
    caches them once their are calculated.
    """

    if self._assemble_cache: return self._assemble_cache


    self._assemble_cache = ()
    return self._assemble_cache

  def form_term_rhs(self, state, w):
    return - state.material.ms * Constant(Constants.gamma) \
        * inner(grad(self.calculate_potential(state)), w)

  def calculate_u1(self, m, V):
    class Cache(): pass
    if not hasattr(self, '_assemble_cache_u1'):
      cache = self._assemble_cache_u1 = Cache()

      ### define Function spaces
      VV   = m.function_space()
      mesh = V.mesh()

      u = TrialFunction(V)
      v = TestFunction(V)

      ### solve u1 neumann-problem 
      n = FacetNormal(mesh)
      cache.m = Function(VV)
      a = inner(grad(u), grad(v)) * dx
      L = div(cache.m) * v * dx - inner(cache.m, n) * v * ds

      cache.w = Function(V)

      null_vec = Vector(cache.w.vector())
      V.dofmap().set(null_vec, 1.0)
      null_vec *= 1.0/null_vec.norm("l2")
      cache.null_space = VectorSpaceBasis([null_vec])

      cache.A, cache.b = Matrix(), Vector()
      cache.assembler = SystemAssembler(a, L)
      cache.assembler.assemble(cache.A)

      cache.solver = KrylovSolver(cache.A, "cg")
      cache.solver.set_nullspace(cache.null_space)

    else:
      #TODO perform cache sanity check
      cache = self._assemble_cache_u1

    cache.m.assign(m)
    cache.assembler.assemble(cache.b)
    cache.null_space.orthogonalize(cache.b)
    cache.solver.solve(cache.w.vector(), cache.b)

    return cache.w

  def calculate_u2_bc(self, u1, V):
    class Cache(): pass
    if not hasattr(self, '_assemble_cache_u2_bc'):
      cache = self._assemble_cache_u2_bc = Cache()

      cache.boundary_mesh = BoundaryMesh(u1.function_space().mesh(), "exterior", False)
      cache.bm_coords     = cache.boundary_mesh.coordinates()
      cache.bm_cells      = cache.boundary_mesh.cells()
      cache.bm_nodes      = cache.boundary_mesh.entity_map(0).array().astype(np.int64)
      cache.mapping       = np.array(vertex_to_dof_map(u1.function_space())).take(cache.bm_nodes)

      # import mesh from Fenics
      grid = createGridFactory().createGridFromConnectivityArrays('triangular', cache.bm_coords.transpose(), cache.bm_cells.transpose())

      # set quadrature strategies
      accuracyOptions = createAccuracyOptions()
      accuracyOptions.doubleRegular.setRelativeQuadratureOrder(5)
      accuracyOptions.doubleSingular.setRelativeQuadratureOrder(5)
      accuracyOptions.singleRegular.setRelativeQuadratureOrder(5)
      quadStrategy = createNumericalQuadratureStrategy("float64", "float64", accuracyOptions)

      # Create assembly context and initialize spaces 
      assemblyOptions = createAssemblyOptions()
      assemblyOptions.switchToAcaMode(createAcaOptions()) # needs AHMED library
      cache.context = createContext(quadStrategy, assemblyOptions)
      cache.pwiseLinears = createPiecewiseLinearContinuousScalarSpace(cache.context, grid)

      # Construct elementary operators
      cache.dlpOp = createLaplace3dDoubleLayerBoundaryOperator(cache.context, cache.pwiseLinears, cache.pwiseLinears, cache.pwiseLinears)
    else:
      #TODO perform cache sanity check
      cache = self._assemble_cache_u2_bc

    # Construct the grid function representing the (input) Dirichlet data
    u1_BEM = createGridFunction(cache.context, cache.pwiseLinears, cache.pwiseLinears, coefficients=u1.vector()[cache.mapping])
    u2_BEM = cache.dlpOp * u1_BEM

    # set u2 dirichlet boundary conditions
    V = u1.function_space()

    coef = u2_BEM.coefficients()
    u2_BC = Function(V)
    u2_BC.vector()[cache.mapping] = coef

    return DirichletBC(V, u2_BC, DomainBoundary())

  def calculate_u2(self, bc, V):
    class Cache(): pass
    if not hasattr(self, '_assemble_cache_u2'):
      cache = self._assemble_cache_u2 = Cache()
      u = TrialFunction(V)
      v = TestFunction(V)

      # define u2 dirichlet-problem 
      a = inner(grad(u), grad(v)) * dx
      L = Constant(0.0) * v * dx

      cache.A = assemble(a)
      cache.b = assemble(L)

      cache.u2 = Function(V)
    else:
      #TODO perform cache sanity check
      cache = self._assemble_cache_u2

    bc.apply(cache.A, cache.b)
    solver = KrylovSolver(cache.A, "cg", "amg")
    solver.solve(cache.u2.vector(), cache.b)

    return cache.u2

  def calculate_potential(self, state):
    """
    Calculate the stray-field for a given simulation state

    *Arguments*
        state
            The simulation state
    """

    # extract magnetic part of mesh if necessary
    class Cache(): pass
    if not hasattr(self, '_assemble_cache'):
      cache = self._assemble_cache = Cache()

      if state.mesh_has_domains():
        cache.mesh = WrappedMesh.create(state.mesh, state.domain_ids('magnetic'))
        cache.V = state.FunctionSpace(cache.mesh)
      else:
        cache.V = state.FunctionSpace()
    else:
      #TODO perform cache sanity check
      cache = self._assemble_cache

    m = cache.mesh.cut(state.m) if state.mesh_has_domains() else state.m

    u1 = self.calculate_u1(m, cache.V)
    bc = self.calculate_u2_bc(u1, cache.V)
    u2 = self.calculate_u2(bc, cache.V)

    result = Function(cache.V, - 0.5 * u1.vector() - u2.vector())

    if state.mesh_has_domains():
      return cache.mesh.expand(result)
    else:
      return result
