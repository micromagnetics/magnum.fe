"""This module defines a class for the micromagnetic stray-field
computation using the FEM-BEM coupling as proposed by Fredkin and Koehler."""

# Copyright (C) 2011-2012 Claas Abert
#
# This file is part of magnum.fe. 
#
# magnum.fe is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# magnum.fe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with magnum.fe. If not, see <http://www.gnu.org/licenses/>.
# 
# First added:  2012-11-30
# Last changed: 2012-11-30

from __future__ import absolute_import 

from dolfin import *
try:
  from bempp.lib import *
  _found_bempp = True
except:
  # TODO log warning
  _found_bempp = False

import numpy as np

from magnumfe.llg_terms import LLGTerm
from magnumfe.constants import Constants

__all__ = ["DemagFieldFK"]

# TODO handle differnet regions
class DemagFieldFK(LLGTerm):
  """
  This class defines methods for the micromagnetic stray-field computation.
  It uses the FEM-BEM coupling as proposed by Fredkin and Koehler.
  """

  def __init__(self):
    """
    Create a _DemagFieldFK_ object.
    """
    #if not _found_bempp: TODO log warning

  def _assemble(self, state):
    """
    Helper method that assembles the mesh dependent system matrices and
    caches them once their are calculated.
    """

    if self._assemble_cache: return self._assemble_cache


    self._assemble_cache = ()
    return self._assemble_cache

  def form_term(self, state, w):
    return - state.material.ms * Constant(Constants.gamma) \
        * inner(grad(self.calculate_potential(state)), w)

  def calculate_u1(self, state):
    class Cache(): pass
    if not hasattr(self, '_assemble_cache_u1'):
      cache = self._assemble_cache_u1 = Cache()

      ### define Function spaces
      #	use linear Lagrange elements for u and set int(u) = 0 in order to 
      #	fix the offset.
      VV = state.VectorFunctionSpace()
      V  = state.FunctionSpace()

      u = TrialFunction(V)
      v = TestFunction(V)

      ### solve u1 neumann-problem 
      n = FacetNormal(state.mesh)
      cache.m = Function(VV)
      a = inner(grad(u), grad(v)) * dx
      L = - div(cache.m) * v * dx - inner(cache.m, n) * v * ds

      cache.w = Function(V)

      null_vec = Vector(cache.w.vector())
      V.dofmap().set(null_vec, 1.0)
      null_vec *= 1.0/null_vec.norm("l2")
      cache.null_space = VectorSpaceBasis([null_vec])

      cache.A, cache.b = Matrix(), Vector()
      cache.assembler = SystemAssembler(a, L)
      cache.assembler.assemble(cache.A)

      cache.solver = KrylovSolver(cache.A, "cg")
      cache.solver.set_nullspace(cache.null_space)

    else:
      #TODO perform cache sanity check
      cache = self._assemble_cache_u1

    cache.m.assign(state.m)
    cache.assembler.assemble(cache.b)
    cache.null_space.orthogonalize(cache.b)
    cache.solver.solve(cache.w.vector(), cache.b)

    return cache.w

  def calculate_u2_bc(self, state, u1):
    class Cache(): pass
    if not hasattr(self, '_assemble_cache_u2_bc'):
      cache = self._assemble_cache_u2_bc = Cache()

      cache.boundary_mesh = BoundaryMesh(state.mesh, "exterior", False)
      cache.bm_coords     = cache.boundary_mesh.coordinates()
      cache.bm_cells      = cache.boundary_mesh.cells()
      cache.bm_nodes      = cache.boundary_mesh.entity_map(0).array().astype(np.int64)
      cache.mapping       = np.array(vertex_to_dof_map(state.FunctionSpace())).take(cache.bm_nodes)

      # import mesh from Fenics
      grid = createGridFactory().createGridFromConnectivityArrays('triangular', cache.bm_coords.transpose(), cache.bm_cells.transpose())

      # set quadrature strategies
      accuracyOptions = createAccuracyOptions()
      accuracyOptions.doubleRegular.setRelativeQuadratureOrder(4)
      accuracyOptions.doubleSingular.setRelativeQuadratureOrder(4)
      accuracyOptions.singleRegular.setRelativeQuadratureOrder(4)
      quadStrategy = createNumericalQuadratureStrategy("float64", "float64", accuracyOptions)

      # Create assembly context and initialize spaces 
      assemblyOptions = createAssemblyOptions()
      #assemblyOptions.switchToAcaMode(createAcaOptions()) # needs AHMED library
      cache.context = createContext(quadStrategy, assemblyOptions)
      cache.pwiseLinears = createPiecewiseLinearContinuousScalarSpace(cache.context, grid)

      # Construct elementary operators
      cache.dlpOp = createLaplace3dDoubleLayerBoundaryOperator(cache.context, cache.pwiseLinears, cache.pwiseLinears, cache.pwiseLinears)
      # XXX removing this leads to weard python errors. why?
      #cache.idOp  = createIdentityOperator(cache.context, cache.pwiseLinears, cache.pwiseLinears, cache.pwiseLinears) 
    else:
      #TODO perform cache sanity check
      cache = self._assemble_cache_u2_bc

    # Construct the grid function representing the (input) Dirichlet data
    #u1_BEM = createGridFunction(cache.context, cache.pwiseLinears, cache.pwiseLinears, lambda p: self._function_eval(p, u1))
    u1_BEM = createGridFunction(cache.context, cache.pwiseLinears, cache.pwiseLinears, coefficients=u1.vector()[cache.mapping])
    u2_BEM = cache.dlpOp * u1_BEM

    # set u2 dirichlet boundary conditions
    V = state.FunctionSpace()

    coef = u2_BEM.coefficients()
    u2_BC = Function(V)
    u2_BC.vector()[cache.mapping] = coef
    #for i in range(len(coef)):
    #  u2_BC.vector()[vertex_to_dof_map(V)[cache.bm_nodes[i]]] = coef[i]

    return DirichletBC(V, u2_BC, DomainBoundary())

  def calculate_u2(self, state, bc):
    class Cache(): pass
    if not hasattr(self, '_assemble_cache_u2'):
      cache = self._assemble_cache_u2 = Cache()
      V = state.FunctionSpace()
      u = TrialFunction(V)
      v = TestFunction(V)

      # define u2 dirichlet-problem 
      a = inner(grad(u), grad(v)) * dx
      L = Constant(0.0) * v * dx

      cache.A = assemble(a)
      cache.b = assemble(L)

      cache.u2 = Function(V)

    else:
      #TODO perform cache sanity check
      cache = self._assemble_cache_u2

    bc.apply(cache.A, cache.b)
    solver = KrylovSolver(cache.A, "cg", "amg")
    solver.solve(cache.u2.vector(), cache.b)

    return cache.u2

  def calculate_potential(self, state):
    """
    Calculate the stray-field for a given simulation state

    *Arguments*
        state
            The simulation state
    """
    u1 = self.calculate_u1(state)
    bc = self.calculate_u2_bc(state, u1)
    u2 = self.calculate_u2(state, bc)

    V = state.FunctionSpace()
    return Function(V, - 0.5 * u1.vector() - u2.vector())

  def _function_eval(self, point, f):
    pos = np.array(point)
    value = np.empty(1)
    f.eval(value, pos)
    return value
