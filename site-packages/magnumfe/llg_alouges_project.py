# Copyright (C) 2011-2015 Claas Abert
#
# This file is part of magnum.fe. 
#
# magnum.fe is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# magnum.fe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with magnum.fe. If not, see <http://www.gnu.org/licenses/>.
# 
# Last modified by Claas Abert, 2015-01-05

from __future__ import absolute_import 

from magnumfe import DofAssembler, ScalarProductMatrix, Constants, NormalizedVector
from dolfin import *

import time

__all__ = ["LLGAlougesProject"]

class LLGAlougesProject(object):
  def __init__(self, terms = []):
    r"""
    Solver for the Landau-Lifshitz-Gilbert equation according to Alouges [Alouges2008]_. In this two-step algorithm :math:`\partial_t \vec{m} = \vec{v}` is computed as

    .. math::
        \int_\Omega ( \alpha \vec{v} + \vec{m} \times \vec{v}) \cdot \vec{w} \dx
        + \frac{2 A_\text{ex} \gamma}{\mu_0 M_\text{s}} \int_\Omega \nabla (\vec{m} + \frac{1}{2} k \vec{v}) \cdot \nabla \vec{w} \dx
        + \gamma \int_\Omega \vec{H}_\text{eff} \cdot \vec{w} \dx
        = 0 \quad \forall \quad \vec{w} \in T_{\vec{m}}

    where both the trial and test functions are restricted to :math:`T_{\vec{m}}` which is the tangent space of :math:`\vec{m}` [Abert2013b]_. As suggested in [Goldenits2012]_ the exchange field is integrated implicitly whereas all other contributions to the effective field :math:`\vec{H}_\text{eff}` are integrated explicitly. This class implements the tangent-space restriction through a projection method

    .. math::
      (\mat{I} - \mat{B}^T \mat{B}) \mat{A} \vec{v} = 
      (\mat{I} - \mat{B}^T \mat{B}) \vec{b}

    where :math:`\mat{A}` and :math:`\vec{b}` are the discretized bilinear and linear part of the weak formulation above and :math:`\mat{B}` is a matrix that delivers the node-wise scalar product with :math:`\vec{m}` if applied to a vector field (e.g. :math:`\vec{v}`).

    The integration step itself is performed by application of a node-wise renormalization as proposed by Alouges in [Alouges2008]_:

    .. math::
      \vec{m}_i(t+k) = \frac{\vec{m}_i(t) + k \vec{v}_i}{|\vec{m}_i(t) + k \vec{v}_i|}

    .. note:: This class requires the Petsc Backend to be enabled.

    *Arguments*
      terms (:class:`LLGTerm`)
        Effective Field terms to be considered.
    """

    if not has_linear_algebra_backend("PETSc"):
      # TODO throw exception?
      pass

    self.terms = terms

  def calculate_v(self, state, dt):
    """
    Calculate :math:`\\vec{v}` according to the algorithm introduced above.

    *Arguments*
        state (:class:`State`)
            The simulation state containing the magnetization configuration.
        dt (:class:`float`)
            The time-step size.
    """

    # Initialize mesh and function spaces
    VV = state.VectorFunctionSpace()
    VS = state.FunctionSpace()

    v  = TrialFunction(VV)
    w  = TestFunction(VV)

    #######################################################
    # Forms
    #######################################################
    f_ex  =  Constant(-2.0 / state.scale**2 * Constants.gamma / Constants.mu0) \
             * state.material.Aex / state.material.ms

    # Bilinear form for LLG
    a  = state.material.alpha * dot(v, w) * state.dx('magnetic')
    a += dot(cross(state.m, v), w) * state.dx('magnetic')
    L  = zero()

    # Effective field contributions
    for term in self.terms:
      L += term.form_term_rhs(state, w) * state.dx('magnetic')
      a += term.form_term_lhs(state, w, Constant(0.5 * dt) * v) * state.dx('magnetic')

    #######################################################
    # Assembly
    #######################################################

    # System to solve:
    # (1 - B^t B) A x = (1 - B^t B) b

    class ProjectionOperator(LinearOperator):
      def __init__(self, A, B, u):
        LinearOperator.__init__(self, u.vector(), u.vector())
        self._A  = A
        self._B  = B

      def size(self):
        return self._A.size(0)

      def mult(self, x, y):
        self._B.transpmult(- self._B * self._A * x, y)
        y.axpy(1.0, self._A * x)

    t0 = time.time()

    A  = PETScMatrix()
    A  = assemble(a, tensor = A, keep_diagonal = True)
    A.ident_zeros()
    B  = DofAssembler.assemble(ScalarProductMatrix(VS, VV, state.m))

    b = assemble(L)
    b.axpy(-1.0, B.transpmult(B*b))

    v = Function(VV)
    Op = ProjectionOperator(A, B, v)
    solve(Op, v.vector(), b, "gmres")

    print "LLG: %s" % (time.time() - t0)
    return v

  def step(self, state, dt):
    """
    Calculate :math:`\\vec{m}(t+\Delta t)` for a given timestep.

    *Arguments*
      state (:class:`State`)
        The magnetization configuration.
      dt (:class:`float`)
        The time-step size.
    """

    v = self.calculate_v(state, dt)
    state.m.vector().axpy(dt, v.vector())
    state.m.normalize()
