from __future__ import absolute_import 

from dolfin import *
from magnumfe import *

__all__ = ["LLG2"]

class LLG2:
  def __init__(self, mesh, material, **kwargs):
    # parameters
    self.mesh        = mesh
    self.material    = material
    self.scale       = kwargs.pop('scale', 1.0)
    self.demag_order = kwargs.pop('demag_order', 2)

    # setup function spaces
    self.VV = VectorFunctionSpace(self.mesh, "CG", 1)
    self.VS = FunctionSpace(self.mesh, "CG", 1)
    self.V  = self.VV*self.VS
    
    # set demag field
    self.demag_field = DemagField(self.mesh, order=self.demag_order)

  def interpolate(self, expr):
    return interpolate(expr, self.VV)

  def calculate_dm(self, m, dt, **kwargs):
    # get optional parameters
    u_demag = kwargs.pop('u_demag', None)
    h_ext   = kwargs.pop('h_ext', None)

    # Test and Trial Functions
    (v, sigma) = TrialFunctions(self.V)
    (w, mu)    = TestFunctions(self.V)

    #######################################################
    # Forms
    #######################################################
    f_ex = (- 2.0 * self.material.Aex * self.material.gamma) / \
           (Constants.mu0 * self.material.ms * self.scale**2)

    # Bilinear form
    a  = self.material.alpha * dot(v, w) * dx + dot(cross(m, v), w) * dx # LLG
    a += mu * inner(m, v) * dx + sigma * inner(m, w) * dx                # Lagrange Multipliers
    a += - 0.5 * dt * f_ex * Dx(v[i],j) * Dx(w[i],j) * dx                # Exchange

    # Linear form
    L  = f_ex * Dx(m[i],j) * Dx(w[i],j) * dx                             # Exchange
    if (u_demag is not None):                                            # Demag
      L += - self.material.ms * self.material.gamma * inner(grad(u_demag), w) * dx
    if (h_ext is not None):                                              # External
      L += self.material.gamma * inner(h_ext, w) * dx

    #######################################################
    # Solve the system
    #######################################################
    w = Function(self.V)

    (A, b) = assemble_system(a, L)
    solve(A, w.vector(), b, "bicgstab", "ilu")

    (v, sigma) = w.split()
    dm = interpolate(v, self.VV)

    return dm

  def step(self, m, dt, **kwargs):
    h_ext = kwargs.pop('h_ext', None)

    u_demag = self.demag_field.calculate(m)
    dm      = self.calculate_dm(m, dt, u_demag=u_demag, h_ext=h_ext)
    m.vector().axpy(dt, dm.vector())

    return Function(self.VV, DofAssembler.assemble(NormalizedVector(self.VV, m)))
