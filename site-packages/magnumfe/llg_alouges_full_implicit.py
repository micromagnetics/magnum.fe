# Copyright (C) 2011-2014 Claas Abert
#
# This file is part of magnum.fe. 
#
# magnum.fe is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# magnum.fe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with magnum.fe. If not, see <http://www.gnu.org/licenses/>.
# 
# Last modified by Claas Abert, 2014-12-04

from __future__ import absolute_import 

try:
  import scipy
  from block import *
  from block.iterative import BiCGStab, ConjGrad
  from block.dolfin_util import *
except:
  # TODO log warning (also distinguish scipy and cbc.block)
  _found_cbcblock = False

from magnumfe import DofAssembler, ScalarProductMatrix, TransScalarProductMatrix, Constants, \
                     NormalizedVector, WrappedMesh, MetricMatrix

__all__ = ["LLGAlougesFullImplicit"]

class LLGAlougesFullImplicit(object):
  """
  Fully implicit solver for the Landau-Lifshitz-Gilbert equation including exchange field and demagnetization field according to Alouges [1].

  TODO write down math
  """

  def __init__(self, terms = [], sample_size = None, scale = 1.0, demag_order = 2):
    """
    *Arguments*
        terms (:class:`LLGTerm`)
            Effective Field terms to be considered.
        sample_size (:class:`tuple`)
            Tuple described the size of the sample. Usually this is taken from create_mesh.
        demag_order (:class:`int`)
            The order of CG function used for the potential calculation.
        scale (:class:`float`)
            The scaling of the model. Use 1e-9 if you use nanometers as length measure.
    """

    #if not _found_cbcblock: TODO log warning
    if sample_size == None: raise "sample_size must be provided for shell-transform method"

    # parameters
    self.terms       = terms
    self.sample_size = sample_size
    self.demag_order = demag_order
    self.scale       = scale

  def interpolate(self, expr):
    return interpolate(expr, self.VV)

  def calculate_v(self, state, dt):
    """
    Calculate :math:`\\vec{v}` according to the algorithm introduced above.

    *Arguments*
        state (:class:`State`)
            The simulation state containing the magnetization configuration.
        dt (:class:`float`)
            The time-step size.
    """

    if parameters["linear_algebra_backend"] == "Epetra":
      from block.algebraic.trilinos import DD_ILU, InvDiag, collapse, LumpedInvDiag
      ILU = DD_ILU
    elif parameters["linear_algebra_backend"] == "PETSc":
      from block.algebraic.petsc import ILU, InvDiag, collapse, LumpedInvDiag
    else:
      raise Exception("Backend not supported")

    class Cache(): pass
    if not hasattr(self, '_assemble_cache'):
      cache = self._assemble_cache = Cache()

      if isinstance(state.mesh, WrappedMesh):
        raise Exception("Use simple mesh with shell instaed of WrappedMesh.")

      # setup function spaces
      cache.VV = VectorFunctionSpace(state.mesh, "CG", 1)
      cache.VD = FunctionSpace(state.mesh, "CG", self.demag_order)
      cache.VL = FunctionSpace(state.mesh, "CG", 1)

      # setup some stuff for the demag field
      transformation_order = 2 if (self.demag_order == 1) else 2
      cache.gx = MetricMatrix.create_for_cube(self.sample_size, 0, transformation_order)
      cache.gy = MetricMatrix.create_for_cube(self.sample_size, 1, transformation_order)
      cache.gz = MetricMatrix.create_for_cube(self.sample_size, 2, transformation_order)
    

    # Test and Trial Functions
    u     = TrialFunction(cache.VD)
    v     = TrialFunction(cache.VV)
    sigma = TrialFunction(cache.VL)

    w1    = TestFunction(cache.VD)
    w2    = TestFunction(cache.VV)
    w3    = TestFunction(cache.VL)

    #######################################################
    # Define weak forms
    #######################################################
    f_ex = (- 2.0 * state.material.Aex * Constants.gamma) / \
           (Constants.mu0 * state.material.ms * self.scale**2)

    # Bilinear form
    a12  = - 0.5 * Constant(dt) * inner(v, grad(w1)) * state.dx('magnetic')                            # Demag Field, Implicit RHS
    a11  = inner(grad(w1), grad(u))            * state.dx('all') \
         + inner(grad(w1), grad(u))            * state.dx(1000)  \
         + inner(grad(w1), cache.gx * grad(u)) * state.dx(1001)  \
         + inner(grad(w1), cache.gy * grad(u)) * state.dx(1002)  \
         + inner(grad(w1), cache.gz * grad(u)) * state.dx(1003)
    a21  = - Constant(state.material.ms * Constants.gamma) * inner(grad(u), w2) * state.dx('magnetic') # Demag
    a22  = Constant(state.material.alpha) * dot(v, w2) * state.dx('magnetic')                          # LLG
    a22 += dot(cross(state.m, v), w2) * state.dx('magnetic')
    a22 += - 0.5 * Constant(dt * f_ex) * Dx(v[i],j) * Dx(w2[i],j) * state.dx('magnetic')               # Exchange

    # Linear form
    L1 = inner(state.m, grad(w1)) * state.dx('magnetic')                                               # Demag Field
    L2 = Constant(f_ex) * Dx(state.m[i],j) * Dx(w2[i],j) * state.dx('magnetic')                        # Exchange

    for term in self.terms:                                                                            # Additional Terms
      L2  += term.form_term_rhs(state, w2) * state.dx('magnetic')
      #a22 += term.form_term_lhs(state, w2, Constant(0.5 * dt) * v) * state.dx('magnetic')

    #######################################################
    # Define boundary conditions
    #######################################################
    bc1 = DirichletBC(cache.VD, Constant(0.0), DomainBoundary())

    #######################################################
    # Assemble the system
    #######################################################
    A11, b1 = assemble_system(a11, L1, bc1)
    A12 = assemble(a12)
    A21 = assemble(a21)
    A22 = assemble(a22, keep_diagonal=True); A22.ident_zeros()
    A23 = DofAssembler.assemble(TransScalarProductMatrix(cache.VL, cache.VV, state.m))
    A32 = DofAssembler.assemble(ScalarProductMatrix(cache.VL, cache.VV, state.m))
    b2  = assemble(L2)

    #######################################################
    # Schur Ansatz
    #######################################################
    A11p   = ILU(A11)
    A11inv = ConjGrad(A11, precond=A11p)
    z1     = A11inv * b1

    S11    = A22 - A21 * A11inv * A12
    S      = block_mat([[S11, A23],
                        [A32,   0]])

    Sp11   = ILU(A22)
    Sp22   = InvDiag(collapse(A32 * LumpedInvDiag(A22) * A23))
    Sp     = block_mat([[Sp11, A23],
                        [0, -Sp22]]).scheme('sgs')

    Sinv   = BiCGStab(S, precond=Sp, tolerance=1e-8/dt)

    b      = block_vec([b2 - A21*z1, 0])
    v, _   = Sinv * b

    return Function(cache.VV, v)

  def step(self, state, dt):
    """
    Calculate :math:`\\vec{m}(t+\Delta t)` for a given timestep.

    *Arguments*
        state (:class:`State`)
            The magnetization configuration.
        dt (:class:`float`)
            The time-step size.
    """

    v = self.calculate_v(state, dt)

    state.m.vector().axpy(dt, v.vector())
    state.m.normalize()
    state.t += dt
