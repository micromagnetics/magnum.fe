"""This module defines a simulation state"""

# Copyright (C) 2011-2012 Claas Abert
#
# This file is part of magnum.fe. 
#
# magnum.fe is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# magnum.fe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with magnum.fe. If not, see <http://www.gnu.org/licenses/>.
# 
# First added:  2012-11-30
# Last changed: 2012-11-30

from __future__ import absolute_import 

from dolfin import MeshFunction, Measure, FunctionSpace, VectorFunctionSpace, \
    Expression, Constant, interpolate, Constant

from magnumfe import Material

__all__ = ["State"]

class CellExpr(Expression):
  def __init__(self, attr, domains, materials):
    self._attr      = attr
    self._domains   = domains
    self._materials = materials

  def eval_cell(self, result, x, cell):
    try:
      material = self._materials[self._domains[cell.index]]
    except KeyError:
      material = Material()

    try:
      result[0] = getattr(material, self._attr)
    except AttributeError:
      result[0] = 0.0

class VectorCellExpr(Expression):
  def __init__(self, attr, domains, materials):
    self._attr      = attr
    self._domains   = domains
    self._materials = materials

  def eval_cell(self, result, x, cell):
    try:
      material = self._materials[self._domains[cell.index]]
    except KeyError:
      material = Material()

    try:
      values = getattr(material, self._attr)
      result[0] = values[0]
      result[1] = values[1]
      result[2] = values[2]
    except (AttributeError, TypeError):
      result[0] = 0.0
      result[1] = 0.0
      result[2] = 0.0
  def value_shape(self):
    return (3,)

class HomogeneousMaterial(object):
  def __init__(self, material):
    object.__setattr__(self, '_material', material)

  def __setattr__(self, attr, value):
    return setattr(self._material, attr, value)

  def __getattr__(self, attr):
    value = getattr(self._material, attr)

    if isinstance(value, list):
      value = tuple(value)

    return Constant(value)

class CompositeMaterial(object):
  def __init__(self, state):
    self._state = state
    self._cache = {}
    self._materials = {}

  def __setitem__(self, index, value):
    self._materials[index] = value
    self._cache = {}
    return value

  def __getitem__(self, index):
    return self._materials[index]

  def __delitem__(self, index):
    del self._materials[index]
    self._cache = {}

  def __getattr__(self, attr):
    if attr in self._cache:
      return self._cache[attr]

    materials = {}
    for domain in self._materials:
      material = self._materials[domain]
      ids = self._state.domain_ids(domain)
      for id in ids:
        materials[id] = material
    
    # scalar or vector parameter
    V    = None
    expr = None
    for domain in self._materials:
      material = self._materials[domain]
      try:
        value = getattr(material, attr)
        if isinstance(value, tuple) or isinstance(value, list):
          assert len(value) == 3
          V    = VectorFunctionSpace(self._state.mesh, 'DG', 0)
          expr = VectorCellExpr(attr, self._state.cell_domains, materials)
        else:
          V    = FunctionSpace(self._state.mesh, 'DG', 0)
          expr = CellExpr(attr, self._state.cell_domains, materials)
      except AttributeError:
        continue

    self._cache[attr] = interpolate(expr, V)
    return self._cache[attr]

class State(object):
  def __init__(self, mesh, regions = {'magnetic': 1}, material = None, **kwargs):
    self.mesh    = mesh
    self.set_regions(regions)
    #self.facets  = facets

    self.cell_domains  = MeshFunction('size_t', mesh, 3, mesh.domains())
    self.facet_domains = MeshFunction('size_t', mesh, 2, mesh.domains())

    self._dx = Measure('dx', mesh)[self.cell_domains]
    self._dS = Measure('dS', mesh)[self.facet_domains]

    self._VS = FunctionSpace(self.mesh, 'CG', 1)          # TODO lazy initialize
    self._VV = VectorFunctionSpace(self.mesh, 'CG', 1, 3) # TODO lazy initialize

    self.material = material or CompositeMaterial(self)

    for key, value in kwargs.iteritems():
      # XXX really interpolate every entry?
      # maybe it's usefull to allow Constants/Expressions sometimes
      if isinstance(value, Expression) or isinstance(value, Constant):
        if value.rank() == 0:
          value = interpolate(value, self.FunctionSpace())
        elif value.rank() == 1:
          value = interpolate(value, self.VectorFunctionSpace())
        else:
          raise Exception("Not supported")

      setattr(self, key, value)

  @property
  def material(self):
    return self._material

  @material.setter
  def material(self, value):
    if isinstance(value, Material):
      self._material = HomogeneousMaterial(value)
    else:
      self._material = value

  def set_regions(self, regions):
    self.regions = {}
    for material in regions:
      ids = regions[material]
      if isinstance(ids, int):  ids = (ids,)
      if isinstance(ids, list): ids = tuple(ids)
      self.regions[material] = ids

  def domain_ids(self, domain):
    if isinstance(domain, int):
      return [domain]

    if domain == 'all':
      ids = tuple()
      for material in self.regions:
        ids = ids + self.regions[material]
      return tuple(set(ids))
    elif domain[0] == '!':
      ids = set(self.domain_ids('all'))
      for id in self.domain_ids(domain[1:]):
        ids.remove(id)
      return tuple(ids)
    else:
      return self.regions[domain]

  def dx(self, domain = "all", dx = None):
    # return measure for whole mesh if no domains are defined
    if self.mesh.domains().num_marked(3) == 0: return self._dx

    domain_ids = self.domain_ids(domain)
    if len(domain_ids) == 0: return None

    if dx == None: dx = self._dx

    measure = dx(domain_ids[0])
    for domain_id in domain_ids[1:]:
      measure += dx(domain_id)

    return measure

  def VectorFunctionSpace(self):
    return self._VV

  def FunctionSpace(self):
    return self._VS
