# Copyright (C) 2011-2014 Claas Abert
#
# This file is part of magnum.fe. 
#
# magnum.fe is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# magnum.fe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with magnum.fe. If not, see <http://www.gnu.org/licenses/>.
# 
# Last modified by Claas Abert, 2014-06-10

from __future__ import absolute_import 
import magnumfe.cpp as cpp
from dolfin import Mesh
import numpy

__all__ = ["Mesher"]

class Mesher(cpp.Mesher):
  """
  This class uses the GMSH library to generate dolfin meshes.
  Especially it offers methods to surround arbitrary meshes
  with a cuboid shell that is required for the demagnetization-field
  transformation method.
  
  Creating a cuboid shell assumes that the coordinate origin is
  in the center of the sample mesh (The resulting mesh will be
  symmetric around the coordinate origin).
  
  *Example*
  
      .. code-block:: python
  
          mesher = Mesher()
          mesher.read_file("sample.msh")
          mesher.create_shell(2, 0.1, (10, 10, 10));
          mesh = mesher.mesh()
  """

  def __init__(self):
    super(Mesher, self).__init__()
    self._celldomains = []
    self._facetdomains = []

  def create_cuboid(self, size, n):
    """
    Creates a cuboid of given dimension around the coordinate
    origin.
    
    *Arguments*
        size
            Size of the cuboid.
        n
            Number of mesh points.
    """

    return super(Mesher, self).create_cuboid(
        numpy.array(size, dtype="d"),
        numpy.array(n, dtype="i")
    )

  def create_celldomain(self, domain, domain_id):
    """
    TODO
    """
    # keep reference to domain to avoid DirectorMethodException
    self._celldomains.append(domain)
    return super(Mesher, self).create_celldomain(domain, domain_id)

  def create_facetdomain(self, domain, domain_id):
    """
    TODO
    """
    # keep reference to domain to avoid DirectorMethodException
    self._facetdomains.append(domain)
    return super(Mesher, self).create_facetdomain(domain, domain_id)

  def create_shell(self, d, margin = 0.0, n = (0,0,0), progression = 1.0):
    """
    Creates a cuboid shell around the current sample.
    
    *Arguments*
        d
            Number of layers of the shell mesh.
        margin
            Margin between sample and shell
            (useful for meshes read from file).
        n
            Number of mesh points of shell.
            (only needed if mesh was read from file)
        progression
            Defines coarsening of the shell layers.
            1.0 means no coarsening.
    """

    return super(Mesher, self).create_shell(d, margin, numpy.array(n, dtype="i"), progression)

  def mesh(self, scale = 1.0):
    """
    Mesh the geometry and return dolfin mesh.
    
    *Arguments*
        scale
            Scaling of the mesh. Useful for very small meshes.
    """

    mesh = Mesh()
    super(Mesher, self).mesh(mesh, scale)
    return mesh

  def get_sample_size(self, i = -1, scale = 1.0):
    """
    Returns the sample size (inner-shell size) in a given
    dimension. Scaling used for mesh generation is not considered.
    If no direction is specified a list of sizes is returned.
    
    *Arguments*
        i
            The dimension (direction).
        scale
            Scaling of the mesh.
    """

    if i > 0:
      return super(Mesher, self).get_sample_size(i) * scale

    # return array if if no component is given
    size = []
    for i in range(3):
      size.append(super(Mesher, self).get_sample_size(i) * scale)

    return size

