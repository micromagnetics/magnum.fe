"""This module defines a class for the micromagnetic stray-field
computation using transformation techniques."""

# Copyright (C) 2011-2012 Claas Abert
#
# This file is part of magnum.fe. 
#
# magnum.fe is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# magnum.fe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with magnum.fe. If not, see <http://www.gnu.org/licenses/>.
# 
# First added:  2012-11-30
# Last changed: 2012-11-30

from __future__ import absolute_import 
from dolfin import *
from magnumfe import Mesher, MetricMatrix, WrappedMesh

import time

__all__ = ["DemagField"]

class DemagField:
  """
  This class defines methods for the micromagnetic stray-field computation.
  It uses cuboid transformation techniques of arbitrary order.
  """

  def __init__(self, mesh, order=1):
    """
    Create a _DemagField_ object for a given mesh.

    *Arguments*
        mesh
            The mesh.
        order
            The order of CG function used for the potential calculation.
    """

    self.mesh  = mesh
    self.order = order

    self._assemble_cache = None

  def _assemble(self):
    """
    Helper method that assembles the mesh dependent system matrices and
    caches them once their are calculated.
    """

    if self._assemble_cache: return self._assemble_cache
    VS = FunctionSpace(self.mesh.with_shell, "Lagrange", self.order)
    VV = VectorFunctionSpace(self.mesh.with_shell, "Lagrange", 1)

    v = TestFunction(VS)
    u = TrialFunction(VS)

    sample_size = self.mesh.data['sample_size']
    transformation_order = 1 if (self.order == 1) else 2
    gx = MetricMatrix.create_for_cube(sample_size, 0, transformation_order)
    gy = MetricMatrix.create_for_cube(sample_size, 1, transformation_order)
    gz = MetricMatrix.create_for_cube(sample_size, 2, transformation_order)

    # Dummy magnetization for linear form
    m  = interpolate(Constant((0.0,0.0,0.0)), VV)

    # set up forms and boundary conditions
    dx = Measure("dx")[self.mesh.cell_domains()]

    a = inner(grad(v), grad(u))      * dx(0) \
      + inner(grad(v), grad(u))      * dx(1) \
      + inner(grad(v), gx * grad(u)) * dx(2) \
      + inner(grad(v), gy * grad(u)) * dx(3) \
      + inner(grad(v), gz * grad(u)) * dx(4)

    L = inner(grad(v), m) * dx(0)

    bc = DirichletBC(VS, Constant(0.0), DomainBoundary())

    u = Function(VS)

    # set up assembler and solver objects
    A, b = Matrix(), Vector()
    assembler = SystemAssembler(a, L, bc)
    assembler.assemble(A)

    solver = KrylovSolver(A, "cg", "amg")
    #solver.parameters["report"]                  = False
    #solver.parameters["absolute_tolerance"] = 1e-4
    #solver.parameters["relative_tolerance"] = 1e-4
    solver.parameters["nonzero_initial_guess"]   = True
    #solver.parameters["preconditioner"]["reuse"] = True # TODO seems to do nothing

    self._assemble_cache = (solver, assembler, A, b, bc, m, u)
    return self._assemble_cache

  def calculate(self, m):
    """
    Calculate the stray-field for a given magnetization configuration

    *Arguments*
        m
            The magnetization configuration as Function object
    """
    solver, assembler, A, b, bc, Im, u = self._assemble()

    t0 = time.time()

    Im.assign(self.mesh.expand(m))
    assembler.assemble(b)
    solver.solve(u.vector(), b)

    print "Demag: %s" % (time.time() - t0)

    return self.mesh.cut(u)

  def A(self):
    """
    Returns the assembled matrix.
    """

    return self._assemble()[2]

  @staticmethod
  def create_mesh(*args, **kwargs):
    """
    Creates a WrappedMesh suited for the application of the shell-
    transformation method. Either takes a filename as first argument
    to load the meshed sample or sizes and discretization of a cuboid
    sample.

    *Example*

        .. code-block:: python
            # load from file
            mesh = DemagField.create_mesh("sphere.msh", d=2, margin=0.1, n=(10, 10, 10))

            # create cuboid mesh of size 1.0 x 1.0 x 1.0
            mesh = DemagField.create_mesh((1.0, 1.0, 1.0), (10, 10, 10), d=2)

    *Arguments*
        d
            Number of shell layers.
        scale
            Scale factor used for mesh generation.
        margin
            Margin to the sample when loading sample mesh from a file.
        n
            Discretization of inner cuboid when loading sample mesh from a file.
    """
        
    mesher = Mesher()

    if isinstance(args[0], str):
      mesher.read_file(args[0])
    elif isinstance(args[0], (list, tuple)) and isinstance(args[1], (list, tuple)):
      mesher.create_cuboid(args[0], args[1])
    else:
      error("Arguments not supported.")

    d     = kwargs.pop('d', 1)
    scale = kwargs.pop('scale', 1.0)
    mesher.create_shell(d, **kwargs)

    mesh    = mesher.mesh(scale)

    return WrappedMesh.create(mesh, 0, {'sample_size': mesher.get_sample_size(scale=scale)})
