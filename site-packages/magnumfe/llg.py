from __future__ import absolute_import 

import scipy
from dolfin import *
from block  import *
from block.algebraic import *
from block.iterative import *
from block.algebraic.trilinos import *
from block.dolfin_util import *
from magnumfe import *

import time

__all__ = ["LLG"]

class LLG:
  def __init__(self, mesh, material, **kwargs):
    self.mesh     = mesh
    self.material = material
    self.scale    = 1e9

    self.VV = VectorFunctionSpace(self.mesh, "CG", 1, 3)
    self.VS = FunctionSpace(self.mesh, "CG", 1)

    #self._assemble_cache = None

 # def _assemble(self):
 #   if self._assemble_cache: return self._assemble_cache

 #   VV = VectorFunctionSpace(self.mesh, "CG", 1, 3)
 #   VS = FunctionSpace(self.mesh, "CG", 1)

 #   self._assemble_cache = (VV, VS)
 #   return self._assemble_cache


  def calculate_dm(self, m, dt, u_demag):
    # Initialize mesh and function spaces
    #VV = VectorFunctionSpace(self.mesh, "CG", 1, 3)
    #VS = FunctionSpace(self.mesh, "CG", 1)
    v  = TrialFunction(self.VV)
    w  = TestFunction(self.VV)

    # LLG Constributions
    a_llg   = self.material.alpha * dot(v, w) * dx + dot(cross(m, v), w) * dx

    f_ex    = (- 2.0 * self.scale**2 * self.material.Aex * self.material.gamma) / \
              (Constants.mu0 * self.material.ms)

    L_ex    = f_ex * Dx(m[i],j) * Dx(w[i],j) * dx
    a_ex    = 0.5 * dt * f_ex * Dx(v[i],j) * Dx(w[i],j) * dx

    L_demag = self.material.gamma * inner(grad(u_demag), w) * dx

    # LLG
    a = a_llg + a_ex
    L = L_ex + L_demag

    # assemble llg
    print "Assemble Matrix"
    t0 = time.time()
    A = assemble(a)
    b = assemble(L)


    # assemble constraint
    B  = DofAssembler.assemble(ScalarProductMatrix(self.VS, self.VV, m))
    BT = DofAssembler.assemble(TransScalarProductMatrix(self.VS, self.VV, m))

    # assemble block matrix
    AA = block_mat([[A, BT],
                    [B, 0]])
    bb = block_vec([b, BT.create_vec()])

    print "Precondition"
    Ap = ILU(A)
    Bp = InvDiag(collapse(B*InvDiag(A)*BT))
    AAp = block_mat([[Ap, 0],
                     [0, Bp]])

    # Solver
    print "Solve"
    AAinv = LGMRES(AA, precond=AAp)
    u, foo = AAinv*bb

    dm = Function(self.VV)
    dm.vector()[:] = u
    print "LLG: %s" % (time.time() - t0)

    return dm

  def integrate(self, m0, T):
    dt = 1e-9
    demag_field = DemagField(self.mesh, order=2)

    # loop
    m = m0
    t = 0
    print "loop"
    while t < T:
      print "demag"
      u_demag = demag_field.calculate(m)
      print "dm"
      dm      = self.calculate_dm(m, 1e-9, u_demag)
      print "integrate"
      new_v = m.vector().axpy(dt, dm.vector())
      m.vector().axpy(dt, dm.vector())
      print "normalize"
      m = Function(self.VV, DofAssembler.assemble(NormalizedVector(self.VV, m)))
      t += dt

    return m
